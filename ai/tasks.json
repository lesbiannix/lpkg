{
  "generated_at": "2025-03-09T00:00:00Z",
  "unfinished": [
    {
      "id": "mlfs-package-import",
      "title": "Import all MLFS packages into lpkg",
      "description": "Parse the Multilib LFS book and scaffold package definitions with optimisation defaults (LTO/PGO/-O3).",
      "owner": "mlfs_researcher",
      "priority": "critical",
      "target_release": "0.3.0",
      "blocked_on": [
        "Finalize metadata -> Rust module generation pipeline",
        "Implement automated parser"
      ],
      "next_actions": [
        "Cross-check ai/metadata coverage vs. MLFS chapter index",
        "Batch-run import workflow in dry-run mode to detect schema gaps",
        "Document manual overrides for multi-pass toolchain packages"
      ],
      "success_metrics": [
        ">= 95% of MLFS packages imported with build/install commands",
        "Generated modules compile under cargo check --features graphql",
        "Metadata index remains <2 seconds to validate on CI"
      ],
      "notes": "Coordinate closely with rust-module-generator to avoid duplicated scaffolding logic."
    },
    {
      "id": "pgo-integration",
      "title": "Integrate profile guided optimization support",
      "description": "Add infrastructure for collection and replay of profiling data during package builds.",
      "owner": "default_cli",
      "priority": "high",
      "blocked_on": [
        "Decide on profiling workload definitions"
      ],
      "next_actions": [
        "Capture baseline timings for release vs release-pgo",
        "Prototype lightweight profiling harness (shell or cargo alias)",
        "Document warmup requirements for long-running packages"
      ],
      "success_metrics": [
        "release-pgo builds show >8% speedup on binutils/gcc workloads",
        "PGO instrumentation + merge flow documented in README",
        "CI job ensures profiles are optional but never stale"
      ]
    },
    {
      "id": "lfs-html-parsers",
      "title": "Automate LFS/BLFS/GLFS ingest via HTML parsing",
      "description": "Avoid hardcoded package data; download the upstream books (LFS, BLFS, GLFS) and parse them to drive scaffolding and metadata updates.",
      "owner": "mlfs_researcher",
      "priority": "medium",
      "blocked_on": [
        "Design resilient scraping strategies for each book",
        "Implement incremental update workflow"
      ],
      "next_actions": [
        "Audit selectors currently used by ai/metadata harvester",
        "Introduce regression fixtures for common chapter archetypes",
        "Add revalidation mode to detect silent upstream markup changes"
      ],
      "risks": [
        "Upstream XHTML sometimes reflows anchors without notice",
        "Need rate limiting/backoff when mirrors throttle requests"
      ]
    },
    {
      "id": "rust-module-generator",
      "title": "Generate package modules from harvested metadata",
      "description": "Transform harvested metadata into Rust files under src/pkgs/by_name, wiring PackageDefinition data directly.",
      "owner": "default_cli",
      "priority": "high",
      "blocked_on": [
        "Define translation scheme from metadata to PackageDefinition",
        "Integrate generator with metadata_indexer output"
      ],
      "next_actions": [
        "Add snapshot tests comparing generated modules vs golden outputs",
        "Extend generator to emit README snippets for each package",
        "Expose --dry-run summary with diff previews"
      ],
      "dependencies": [
        "mlfs-package-import",
        "lfs-html-parsers"
      ]
    },
    {
      "id": "dependency-audit",
      "title": "Keep lpkg dependency footprint lean",
      "description": "Regularly evaluate crates for bloat and replace heavy stacks with std or lightweight alternatives.",
      "owner": "default_cli",
      "priority": "medium",
      "next_actions": [
        "Track remaining crates pulling in large transitive trees (e.g. tracing, actix-only paths)",
        "Automate cargo-tree diff reports in CI",
        "Document substitution patterns (tokio ➜ std, reqwest ➜ ureq, etc.)"
      ],
      "success_metrics": [
        "Default `cargo build` compiles < 140 crates",
        "No async runtimes linked when GraphQL feature is disabled",
        "README lists regeneration commands for all generated assets"
      ],
      "notes": "Continue pruning optional crates (tracing, gptman, uuid) when the TUI feature is off; surface findings in ai/notes.md."
    }
  ],
  "solved": [
    {
      "id": "ai-metadata-store",
      "title": "Create AI metadata directory",
      "description": "Introduce ai/personas.json, ai/tasks.json, ai/bugs.json for persistent assistant context.",
      "resolution": "Initial JSON files checked in with placeholder content.",
      "owner": "default_cli"
    },
    {
      "id": "metadata-schema-v0.1",
      "title": "Define package metadata schema",
      "description": "Specify JSON schema and layout for storing scraped package detail from LFS family books.",
      "resolution": "Added ai/metadata/schema.json with v0.1.0 structure and seeded initial package entry/index.",
      "owner": "default_cli"
    },
    {
      "id": "metadata-indexer-cli",
      "title": "Build metadata validation/indexing tool",
      "description": "Provide a standalone CLI to validate package metadata against the schema and regenerate ai/metadata/index.json.",
      "resolution": "Added src/bin/metadata_indexer.rs with schema validation, summary extraction, and index writer integration.",
      "owner": "default_cli"
    },
    {
      "id": "metadata-jhalfs-refresh",
      "title": "Wire jhalfs manifests into metadata harvester",
      "description": "Cache wget-list/md5sums from jhalfs and expose a CLI refresh command so harvesting can populate source URLs and checksums reliably.",
      "resolution": "Extended metadata_indexer with a `refresh` subcommand, cached manifests under ai/metadata/cache/, and hooked harvest to populate MD5 checksums via jhalfs data.",
      "owner": "default_cli"
    },
    {
      "id": "lightweight-http-stack",
      "title": "Replace async HTTP stack with lightweight blocking client",
      "description": "Remove tokio/reqwest default dependency and adopt a minimal HTTP client for CLI workflows.",
      "resolution": "Swapped reqwest/tokio for ureq across html, ingest, and metadata tooling; added PGO-aware Cargo profiles and documented regeneration commands.",
      "owner": "default_cli"
    }
  ]
}
